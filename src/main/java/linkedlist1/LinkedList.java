package linkedlist1;

 interface LinkedList<T> {
    // интерфейс класса, реализующий АТД LinkedList

      int HEAD_NIL = 0;      // head() ещё не вызывалась
      int HEAD_OK = 1;       // последняя команда установки курсора отработала нормально
      int HEAD_ERR = 2;      // список пуст

      int TAIL_NIL = 0;      // tail() ещё не вызывалась
      int TAIL_OK = 1;       // последняя команда установки курсора отработала нормально
      int TAIL_ERR = 2;      // список пуст

      int RIGHT_NIL = 0;     // right() ещё не вызывалась
      int RIGHT_OK = 1;      // последняя команда установки курсора отработала нормально
      int RIGHT_ERR = 2;     // список пуст (курсор не задан) или узел, на который указывает курсор, не имеет соседа справа

      int PUT_RIGHT_NIL = 0; // put_right() ещё не вызывалась
      int PUT_RIGHT_OK = 1;  // последняя команда добавления узла отработала нормально
      int PUT_RIGHT_ERR = 2; // список пуст (курсор не задан)

      int PUT_LEFT_NIL = 0;  // put_left() ещё не вызывалась
      int PUT_LEFT_OK = 1;   // последняя команда добавления узла отработала нормально
      int PUT_LEFT_ERR = 2;  // список пуст (курсор не задан)

      int REMOVE_NIL = 0;    // remove() ещё не вызывалась
      int REMOVE_OK = 1;     // последняя команда удаления узла отработала нормально
      int REMOVE_ERR = 2;    // список пуст (курсор не задан)

      int REPLACE_NIL = 0;   // replace() ещё не вызывалась
      int REPLACE_OK = 1;    // последняя команда замены значения узла отработала нормально
      int REPLACE_ERR = 2;   // список пуст (курсор не задан)

      int FIND_NIL = 0;      // find() ещё не вызывалась
      int FIND_OK = 1;       // последняя команда поиска искомого значения отработала нормально
      int FIND_ERR = 2;      // следующий узел не найден или список пуст (курсор не задан)

      int GET_NIL = 0;       // get() ещё не вызывалась
      int GET_OK = 1;        // последняя команда получения значения текущего узла отработала нормально
      int GET_ERR = 2;       // список пуст (курсор не задан)

    // команды

    // предусловие: список не пуст
    // постусловие: курсор установлен на первый узел в списке
     void head();

    // предусловие: список не пуст
    // постусловие: курсор установлен на последний узел в списке
     void tail();

    // предусловие: список не пуст и текущий узел имеет соседа справа
    // постусловие: курсор сдвинут на один узел вправо
     void right();

    // предусловие: список не пуст
    // постусловие: после текущего узла вставлен новый узел с заданным значением
     void put_right(T value);

    // предусловие: список не пуст
    // постусловие: перед текущим узлом вставлен новый узел с заданным значением
     void put_left(T value);

    // предусловие: список не пуст
    // постусловие: текущий узел удален (курсор смещается к правому соседу, если он есть, в противном случае курсор
    //                                  смещается к левому соседу, если он есть)
     void remove(T value);

    // постусловие: из списка удалятся все значения, курсор сбрасывается, т.к. список пуст
     void clear();

     //предусловие: список пуст
     //постусловие новый узел добавлен
     void add_to_empty(T value);

     // предусловие: список не пуст
    // постусловие: новый узел добавлен в хвост списка
     void add_tail(T value);

    // предусловие: список не пуст
    // постусловие: значение текущего узла заменено на заданное
     void replace(T value);

    // предусловие: список не пуст
    // постусловие: курсор установлен на следующий узел с искомым значением (по отношению к текущему узлу),
    //              если таковой существует
     void find(T value);

     // предусловие: список не пуст
    // постусловие: из списка удалятся все узлы с заданным значением
     void remove_all(T value);


    // запросы

    // предусловие: курсор установлен
     T get();             // получить значение текущего узла

     int size();          // посчитать количество узлов в списке

     boolean is_head();   // находится ли курсор в начале списка?
     boolean is_tail();   // находится ли курсор в конце списка?
     boolean is_value();  // установлен ли курсор на какой-либо узел в списке (по сути, непустой ли список)

    // дополнительные запросы:

     int get_head_status();      // возвращает значение HEAD_
     int get_tail_status();      // возвращает значение TAIL_
     int get_right_status();     // возвращает значение RIGHT_
     int get_put_right_status(); // возвращает значение PUT_RIGHT
     int get_put_left_status();  // возвращает значение PUT_LEFT_
     int get_remove_status();    // возвращает значение REMOVE_
     int get_replace_status();   // возвращает значение REPLACE_
     int get_find_status();      // возвращает значение FIND_
     int get_get_status();       // возвращает значение GET_
}


/*
2.2. Потому что tail имеет сложность сложность O(1), а другие варианты сложность O(N).

2.3. Можно искать с помощью find()
*/
